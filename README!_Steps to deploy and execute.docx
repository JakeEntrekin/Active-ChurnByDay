Steps to deploy and execute

1.	The following files are included in the GitHub submission:
a.	DateTableDDL.sql
b.	DateTableFill.sql -- populates the values for the date dimension
c.	dimAccountDDL.sql
d.	dimAccountFill.sql  -- populates the values for the Account dimension
e.	dimUsersDDL.sql
f.	dimUsersFill.sql ---- populates the values for the Users dimension
g.	viewDimAccountDDL.sql
h.	viewDimUsersDDL.sql
i.	TasksUsedDetailDDL.sql
j.	TasksUsedDetailFill.sql -- populates the data from source_data.tasks_used
k.	factUserActivityDetailDDL.sql
l.	factUserActivityDetailFill.sql – populates the data from TasksUsedDetail
m.	factActiveUsersDDL.sql
n.	factActiveUsersFill.sql  -- populates the data from factUserActivityDetail
o.	factInactiveUsersDDL.sql
p.	factInactiveUsersFill.sql  -- populates the data from factUserActivityDetail
q.	ActiveCountMeasureByDay.sql –query that generates the active user counts by day
r.	ChurnCountMeasurebyDate.sql –query that generates list of churn users by day
2.	The data model was created using DataGrip and using SQL Server SQL Dialect under File – Settings – Database – SQL Dialects – Global/Project SQL Dialect

 
3.	Order of Deployment.  In all of the below scripts, you’ll want to connect to the jentrekin schema, right click the schema name, and select New – Console.  Then you’d want to paste the scripts into the new console window and hit either Cntrl+Enter OR the Play button.
 

 
a.	Execute DateTableDDL.sql
b.	Execute DateTableFill.sql
c.	Execute dimAccountDDL.sql
d.	Execute dimUsersDDL.sql
e.	Execute dimAccountFill.sql
f.	Execute dimUsersFill.sql
g.	Execute viewDimAccountDDL.sql
h.	Execute viewDimUsersDDL.sql
i.	Execute TasksUsedDetailDDL.sql
j.	Execute TasksUsedFill.sql
i.	NOTE this script enables an incremental load, so the first time there’s no need for any modifications.
ii.	Full load executes in approximately 2 minutes or less.
iii.	However, if you in the future need to do a full reload, you would need to uncomment out the truncate statement and then comment out the highlighted lines of the code shown here:
--TRUNCATE TABLE jentrekin.TasksUsedDetail
INSERT INTO jentrekin.TasksUsedDetail ( zap_id, user_id, userkey, account_id, accountkey, date, datekey, min_timestamp, tasks_used, errors)
SELECT t.zap_id, t."user_id ", coalesce(d.userkey, -1) as UserKey,
  t.account_id, coalesce(dAC.accountkey, -1) as AccountKey, t.date,
  cast(replace(cast(t.date as varchar(10)), '-', '') as int) as DateKey, t.min_timestamp, t.tasks_used, t.errors
from source_data.tasks_used t LEFT JOIN jentrekin.dimusers d on t."user_id " = d.user_id
left join jentrekin.dimaccount dAC
  on t.account_id = dAC.account_id
WHERE t.date > (SELECT isnull(MAX(date), '1900-01-01') from jentrekin.tasksuseddetail) --set up incremental load
	          
k.	Execute factUserActivityDDL.sql
l.	Execute factUserActivityDetail.sql
m.	Execute factActiveUsersDDL.sql
n.	Execute factInactiveUsersDDL.sql
o.	Execute factActiveUsersFill.sql
p.	Execute factInactiveUsersDDL.sql
4.	Once the above deployment is complete, you should then be able to run the Churn and Active queries in steps 5 and 6 below.
5.	Execute ChurnCountMeasureByDay.sql to get a count of distinct users who contributed to churn each day.
6.	Execute ActiveCountMeasureByDay.sql to get a count of distinct users who are considered active each day.

